let CONST = {{ False }};
let WRITE = {{ True }};

let points_to = crucible_points_to;
let precond = crucible_precond;
let from_cryptol = crucible_term;
let execute = crucible_execute_func;
let postcond = crucible_postcond;
let returns = crucible_return;
let struct = crucible_struct;
let array = crucible_array;
let pointer rw type = if (eval_bool {{ rw == WRITE }})
                      then crucible_alloc type
                      else crucible_alloc_readonly type;

let uint64_t = llvm_int 64;
let uint32_t = llvm_int 32;
let uint16_t = llvm_int 16;
let uint8_t = llvm_int 8;
let struct_t struct_name = llvm_type (str_concat "%struct." struct_name);

let variable (name : String) (type : LLVMType) = do {
  cryptol_var <- crucible_fresh_var name type;
  return {s=from_cryptol cryptol_var, c=cryptol_var};
};

let alloc (name : String) (rw : Term) (type : LLVMType) = do {
  p <- pointer rw type;
  v <- variable name type;
  points_to p v.s;
  return {p=p, s=v.s, c=v.c};
};

let list (name : String) (rw : Term) (size : Int) (basetype : LLVMType) = do {
  let type = llvm_array size basetype;
  value <- alloc name rw type;
  return {p=value.p, s=value.s, c=value.c};
};

//Here the pointer points to a sting of size `size+1` that is NULL
//terminated. The Cryptol value does not have the NULL at the end of
//the string.
let string_t (string_name : String) (rw : Term) (size : Int) = do {
  string <- crucible_fresh_var string_name (llvm_array size uint8_t);
  pstring <- pointer rw (llvm_array (eval_int {{ `size + 1 : [64] }}) uint8_t);
  points_to pstring (from_cryptol {{ string # [0] }});
  return {p=pstring, s=from_cryptol string, c=string};
};

let string_t' (string_name : String) (size : Int) = do {
  string <- list "string" CONST (eval_int {{ `(size+1) : [64] }}) uint8_t;
  let s = string.c;
  postcond {{ s@(`size : [64]) == 0 }};
  return {p=string.p, s=from_cryptol string.c, c=string.c};
};

let error = do {
  crucible_precond {{ True }};
  crucible_postcond {{ True }};
  return {{ True }};
};

let noerror = do {
  return {{ True }};
};

let struct_list_empty = do {
  return {s=[], c={{ [] }}} : CrucibleSetup {s : [SetupValue], c : Term};
};

rec struct_list_rec (numElements : Int) (init_function : a -> CrucibleSetup {s : SetupValue, c : Term}) (params : a) = do {
  err <- if (eval_bool {{ (`numElements : [32]) == 0 }}) then error else noerror; //numElements must be greater than 0
  element <- init_function params : CrucibleSetup {s : SetupValue, c : Term};
  rest <- if (eval_bool {{ (`numElements : [32]) == 1 }}) then struct_list_empty
          else struct_list_rec (eval_int {{ (`numElements : [32]) - 1 }}) init_function params : CrucibleSetup {s : [SetupValue], c : Term};

  let ret_s = (concat [element.s] rest.s) : [SetupValue];

  let element_c = element.c;
  let rest_c = rest.c;
  let ret_c = {{ [element_c] # rest_c : [numElements]_ }} : Term;

  return {s=ret_s, c=ret_c};
};

let struct_list (rw : Term) (numElements : Int) (init_function : a -> CrucibleSetup {s : SetupValue, c : Term}) (params : a) (type : LLVMType) = do {
  list <- struct_list_rec numElements init_function params : CrucibleSetup {s : [SetupValue], c : Term};
  let arr = array list.s;
  p <- pointer rw (llvm_array numElements type);
  points_to p arr;
  return {p=p : SetupValue, s=arr : SetupValue, c=list.c : Term};
};

let {{
  hexstring_to_bv : {a} (fin a) => [a][8] -> [a*4]
  hexstring_to_bv s =
    join [ drop (if (c >= 'a' /\ c <= 'f') then (c - 'a') + 10
                  | (c >= 'A' /\ c <= 'F') then (c - 'A') + 10
                  | (c >= '0' /\ c <= '9') then (c - '0')
                 else 0) : [4]
         | c <- s ]

  bv_to_hexstring : {a} (fin a) => [a*4] -> [a][8]
  bv_to_hexstring bv = [ (if d >= 10
                          then (0#d) + 'a' - 10
                          else (0#d) + '0')
                       | d <- groupBy`{4} bv ]

  hexstring_inverts x = hexstring_to_bv (bv_to_hexstring x) == x

  from_list : {a, b} (fin a, fin b, a*64 >= b) => [a][64] -> [b]
  from_list List = drop (join (reverse List))
  
  to_List bv = reverse(groupBy`{64} (0#bv))

  popcount : {a} (fin a) => [a] -> [32]
  popcount bs = counts!0
    where counts = [0] # [(0#[b]) + c | b <- bs | c <- counts]
}};

bitvector_bc <- llvm_load_module "../obj/bitvector.bc";

let bitvector_t_setup (name : String) (rw : Term) (n : Int) = do {
  let nLength = {{ `(n /^ 64) : [64] }};
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  List <- list (str_concat name ".bits->pList") rw (eval_int {{ `(n /^ 64) : [64] }}) uint64_t;
  let nBits = {{ `n : [32] }};
  let bv_struct = (struct [from_cryptol nBits,
                           struct [from_cryptol nLength,
                                   nLength_max.s,
                                   List.p]]);

  return {struct=bv_struct, nBits=nBits, nLength=nLength, nLength_max=nLength_max.c, List=List};
};

let bitvector_t (name : String) (rw : Term) (n : Int) = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  pbv <- pointer rw (struct_t "bitvector_t");
  points_to pbv bv.struct;

  return {p=pbv, struct=bv.struct, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t' (name : String) (n : Int) (pbv : SetupValue) = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  points_to pbv bv.struct;

  return {p=pbv, struct=bv.struct, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t_struct (name : String, rw : Term, n : Int) = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  return {s=bv.struct, c=(bv.List).c};
};

let bitvector_t_struct' (name : String,  n : Int) = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  return {s=bv.struct, c=(bv.List).c};
};

let sequence_t (name : String) (rw : Term) (nLength : Int) (nBits : Int) = do {
  List <- struct_list rw nLength bitvector_t_struct ((str_concat name ".pList"), rw, nBits) (struct_t "bitvector_t");
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  let seq_struct = struct [ from_cryptol {{ `nLength : [64] }},
                            nLength_max.s,
                            List.p ];

  let nLength_max_c = nLength_max.c;
  precond {{ (`nLength_max_c : [64]) >= (`nLength : [64])}};
  pseq <- pointer rw (llvm_array nLength (struct_t "sequence_t"));
  points_to pseq seq_struct;

  return {p=pseq, struct=seq_struct, nBits=from_cryptol {{ `nBits : [64] }}, nLength=from_cryptol {{ `nLength : [64] }}, nLength_max=nLength_max.c, List=List};
};

let sequence_t' (name : String) (nLength : Int) (nBits : Int) (pseq : SetupValue) = do {
  List <- struct_list CONST nLength bitvector_t_struct' ((str_concat name ".pList"), nBits) (struct_t "bitvector_t");
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  let seq_struct = struct [ from_cryptol {{ `nLength : [64] }},
                            nLength_max.s,
                            List.p ];
  let nLength_max_c = nLength_max.c;
  postcond {{ (nLength_max_c : [64]) >= (`nLength : [64])}};
  points_to pseq seq_struct;

  return {p=pseq, struct=seq_struct, nBits=from_cryptol {{ `nBits : [64] }}, nLength=from_cryptol {{ `nLength : [64] }}, nLength_max=nLength_max.c, List=List};
};

let bv_verify function_name overrides spec =
  crucible_llvm_verify bitvector_bc function_name overrides true spec z3;


//sequence_t *bitvector_t_split(bitvector_t *bv, uint32_t parts)
let bitvector_t_split_spec (n : Int) (parts : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p, from_cryptol {{ `parts : [32] }}];

  pseq <- pointer CONST (struct_t "sequence_t");
  seq <- sequence_t' "sequence" parts n pseq;

  let List_seq = (seq.List).c;
  let List_bv = (bv.List).c;

  postcond {{ split`{parts=parts} (from_list`{b=n} List_bv) == [ from_list`{b=n/parts} List_seqi | List_seqi <- List_seq ] }};

  returns pseq;
};

bitvector_t_split_result <-
  bv_verify "bitvector_t_split" [] (bitvector_t_split_spec 3 1);
