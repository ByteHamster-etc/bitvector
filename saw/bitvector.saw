let CONST = {{ False }};
let WRITE = {{ True }};

let points_to = crucible_points_to;
let precond = crucible_precond;
let from_cryptol = crucible_term;
let execute = crucible_execute_func;
let postcond = crucible_postcond;
let returns = crucible_return;
let struct = crucible_struct;
let pointer rw type = if (eval_bool {{ rw == WRITE }})
                      then crucible_alloc type
                      else crucible_alloc_readonly type;

let uint64_t = llvm_int 64;
let uint32_t = llvm_int 32;
let uint16_t = llvm_int 16;
let uint8_t = llvm_int 8;
let struct_t struct_name = llvm_type (str_concat "%struct." struct_name);

let variable name type = do {
  cryptol_var <- crucible_fresh_var name type;
  return {s=from_cryptol cryptol_var, c=cryptol_var};
};

let alloc name rw type = do {
  p <- pointer rw type;
  v <- variable name type;
  points_to p v.s;
  return {p=p, s=v.s, c=v.c};
};

let list name rw size basetype = do {
  let type = llvm_array size basetype;
  value <- alloc name rw type;
  return {p=value.p, s=value.s, c=value.c};
};

//Here the pointer points to a sting of size `size+1` that is NULL
//terminated. The Cryptol value does not have the NULL at the end of
//the string.
let string_t string_name rw size = do {
  string <- crucible_fresh_var string_name (llvm_array size uint8_t);
  pstring <- pointer rw (llvm_array (eval_int {{ `size + 1 : [64] }}) uint8_t);
  points_to pstring (from_cryptol {{ string # [0] }});
  return {p=pstring, s=from_cryptol string, c=string};
};

let string_t' string_name size = do {
  string <- list "string" CONST (eval_int {{ `(size+1) : [64] }}) uint8_t;
  let s = string.c;
  postcond {{ s@(`size : [64]) == 0 }};
  return {p=string.p, s=from_cryptol string.c, c=string.c};
};


let {{
  hexstring_to_bv : {a} (fin a) => [a][8] -> [a*4]
  hexstring_to_bv s =
    join [ drop (if (c >= 'a' /\ c <= 'f') then (c - 'a') + 10
                  | (c >= 'A' /\ c <= 'F') then (c - 'A') + 10
                  | (c >= '0' /\ c <= '9') then (c - '0')
                 else 0) : [4]
         | c <- s ]

  bv_to_hexstring : {a} (fin a) => [a*4] -> [a][8]
  bv_to_hexstring bv = [ (if d >= 10
                          then (0#d) + 'a' - 10
                          else (0#d) + '0')
                       | d <- groupBy`{4} bv ]

  hexstring_inverts x = hexstring_to_bv (bv_to_hexstring x) == x

  from_list : {a, b} (fin a, fin b, a*64 >= b) => [a][64] -> [b]
  from_list List = drop (join (reverse List))
  
  to_List bv = reverse(groupBy`{64} (0#bv))

  popcount : {a} (fin a) => [a] -> [32]
  popcount bs = counts!0
    where counts = [0] # [(0#[b]) + c | b <- bs | c <- counts]
}};

bitvector_bc <- llvm_load_module "../obj/bitvector.bc";

let bitvector_t_setup name rw n = do {
  let nLength = {{ `(n /^ 64) : [64] }};
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  List <- list (str_concat name ".bits->pList") rw (eval_int {{ `(n /^ 64) : [64] }}) uint64_t;
  let nBits = {{ `n : [32] }};
  let bv_struct = (struct [from_cryptol nBits,
                           struct [from_cryptol nLength,
                                   nLength_max.s,
                                   List.p]]);

  return {struct=bv_struct, nBits=nBits, nLength=nLength, nLength_max=nLength_max.c, List=List};
};

let bitvector_t name rw n = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  pbv <- pointer rw (struct_t "bitvector_t");
  points_to pbv bv.struct;

  return {p=pbv, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t' name n pbv = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  points_to pbv bv.struct;

  return {p=pbv, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let nBits = 200;
let nBits2 = 137;
let nBitsToAdd = 10;
let nBitsToDrop = 10;
let nHexChars = 17;
let nBytes = 23;
let slicestart = 54;
let slicelength = 113;

let bv_verify function_name overrides spec =
  crucible_llvm_verify bitvector_bc function_name overrides true spec z3;


//void bitvector_t_zeroize(bitvector_t *bv)
let bitvector_t_zeroize_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;

  let List' = (bv'.List).c;
  postcond {{ List' == (zero : [n /^ 64][64]) }};
};

bitvector_t_zeroize_result <-
  bv_verify "bitvector_t_zeroize" [] (bitvector_t_zeroize_spec nBits);


//bitvector_t *bitvector_t_alloc(uint32_t nBits)
let bitvector_t_alloc_spec (nBits : Int) = do {
  execute [from_cryptol {{ `nBits : [32] }}];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" nBits pbv;

  let List' = (bv'.List).c;
  postcond {{ List' == (zero : [nBits /^ 64][64]) }};

  returns pbv;
};

bitvector_t_alloc_result <-
  bv_verify "bitvector_t_alloc" [bitvector_t_zeroize_result] (bitvector_t_alloc_spec nBits);


//void bitvector_t_copyUpdate(bitvector_t *dst, bitvector_t *src)
let bitvector_t_copyUpdate_spec (n : Int) = do {
  dst <- bitvector_t "dst" WRITE n;
  src <- bitvector_t "src" CONST n;
  execute [dst.p, src.p];

  dst' <- bitvector_t' "dst'" n dst.p;

  let (s_List, d_List') = ((src.List).c, (dst'.List).c);
  postcond {{ s_List == d_List' }};
};

bitvector_t_copyUpdate_result <-
  bv_verify "bitvector_t_copyUpdate" [] (bitvector_t_copyUpdate_spec nBits);


//bitvector_t *bitvector_t_copy(bitvector_t *bv) {
let bitvector_t_copy_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p];

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n pret;
  let (List, r_List) = ((bv.List).c, (ret.List).c);
  postcond {{ List == r_List }};
  returns pret;
};

bitvector_t_copy_result <-
  bv_verify "bitvector_t_copy" [bitvector_t_copyUpdate_result] (bitvector_t_copy_spec nBits);


//void bitvector_t_cleanHighBits(bitvector_t *bv)
let bitvector_t_cleanHighBits_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;

  let (List, List') = ((bv.List).c, (bv'.List).c);
  postcond {{ (from_list List : [n]) == from_list List' }};
};

bitvector_t_cleanHighBits_result <-
  bv_verify "bitvector_t_cleanHighBits" [] (bitvector_t_cleanHighBits_spec 64);


//void bitvector_t_widenUpdate(bitvector_t *bv, uint32_t nBitsToAdd)
let bitvector_t_widenUpdate_spec (n : Int) (nBitsToAdd : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToAdd : [32] }}];

  let n' = eval_int {{ `(n + nBitsToAdd) : [32] }};

  bv' <- bitvector_t' "bv'" n' bv.p;

  let (List, List') = ((bv.List).c, (bv'.List).c);
  postcond {{ (0 # (from_list`{b=n} List)) == (from_list`{b=n'} List') }};
};

bitvector_t_widenUpdate_result <-
  bv_verify "bitvector_t_widenUpdate" [] (bitvector_t_widenUpdate_spec nBits nBitsToAdd);

//bitvector_t *bitvector_t_widen(bitvector_t *bv, uint32_t nBitsToAdd)
let bitvector_t_widen_spec (n : Int) (nBitsToAdd : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p, from_cryptol {{ `nBitsToAdd : [32] }}];

  let n' = eval_int {{ `(n + nBitsToAdd) : [32] }};

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (List, r_List) = ((bv.List).c, (ret.List).c);
  postcond {{ (0 # (from_list`{b=n} List)) == (from_list`{b=n'} r_List) }};
  returns pret;
};

bitvector_t_widen_result <-
  bv_verify "bitvector_t_widen" [bitvector_t_widenUpdate_result] (bitvector_t_widen_spec nBits nBitsToAdd);


//bitvector_t *bitvector_t_fromHexString(char *string)
let bitvector_t_fromHexString_spec (n : Int) = do {
  string <- string_t "string" CONST n;

  let s = string.c;
  precond {{ [ (c >= 'a' /\ c <= 'f') \/
               (c >= 'A' /\ c <= 'F') \/
               (c >= '0' /\ c <= '9')
	     | c <- s ] == ~zero }};

  execute [string.p];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" (eval_int {{ `(n*4) : [64] }}) pbv;

  let List' = (bv'.List).c;
  postcond {{ hexstring_to_bv s == from_list List' }};

  returns pbv;
};

bitvector_t_fromHexString_result <-
  bv_verify "bitvector_t_fromHexString" [] (bitvector_t_fromHexString_spec nHexChars);


//char *bitvector_t_toHexString(bitvector_t *bv)
let bitvector_t_toHexString_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE (eval_int {{ `(n*4) : [64] }});

  execute [bv.p];

  string <- string_t' "string" n;

  let (s, List) = (string.c, (bv.List).c);
  postcond {{ bv_to_hexstring`{n} (from_list List) == take s }};

  returns string.p;
};

bitvector_t_toHexString_result <-
  bv_verify "bitvector_t_toHexString" [] (bitvector_t_toHexString_spec nHexChars);


//void bitvector_t_dropUpdate(bitvector_t *bv, uint32_t nBitsToDrop)
let bitvector_t_dropUpdate_spec (n : Int) (nBitsToDrop : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToDrop : [32] }}];

  let n' = eval_int {{ `(n - nBitsToDrop) : [32] }};

  bv' <- bitvector_t' "bv'" n' bv.p;

  let (List, List') = ((bv.List).c, (bv'.List).c);
  postcond {{ drop`{nBitsToDrop} (from_list`{b=n} List) == (from_list`{b=n'} List') }};
};

bitvector_t_dropUpdate_result <-
  bv_verify "bitvector_t_dropUpdate" [] (bitvector_t_dropUpdate_spec nBits nBitsToDrop);
  

//bitvector_t *bitvector_t_drop(bitvector_t *bv, uint32_t nBitsToDrop) {
let bitvector_t_drop_spec (n : Int) (nBitsToDrop : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToDrop : [32] }}];

  //Show that nBits and nLength of the input bv were unchanged
  bv' <- bitvector_t' "bv'" n bv.p;

  let (nBits, nBits') = (bv.nBits, bv'.nBits);
  postcond {{ (nBits : [32]) == (nBits' : [32]) }};

  let (nLength, nLength') = (bv.nLength, bv'.nLength);
  postcond {{ (nLength : [64]) == (nLength' : [64]) }};

  //Show that the result bv is correct
  let n' = eval_int {{ `(n - nBitsToDrop) : [32] }};
  
  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (List, r_List) = ((bv.List).c, (ret.List).c);
  postcond {{ drop`{nBitsToDrop} (from_list`{b=n} List) == (from_list`{b=n'} r_List) }};

  crucible_return pret;
};

bitvector_t_drop_result <-
  bv_verify "bitvector_t_drop" [] (bitvector_t_drop_spec nBits nBitsToDrop);


//void bitvector_t_from_bytes(bitvector_t *bv, uint8_t *bytes, uint32_t nBytes)
let bitvector_t_from_bytes_spec (n : Int) (nBytes : Int) = do {
  bytes <- list "bytes" CONST nBytes uint8_t;

  execute [bytes.p, from_cryptol {{ `nBytes : [32] }}];

  let n' = eval_int {{ `(nBytes * 8) : [32] }};

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" n' pbv;

  let List = (bv'.List).c;
  let b = bytes.c;
  postcond {{ from_list`{b=n'} List == join b }};

  returns pbv;
};

bitvector_t_from_bytes_result <-
  bv_verify "bitvector_t_from_bytes" [bitvector_t_widenUpdate_result] (bitvector_t_from_bytes_spec nBits nBytes);


//uint8_t *bitvector_t_to_bytes(bitvector_t *bv)
let bitvector_t_to_bytes_spec (nBytes : Int) = do {
  bv <- bitvector_t "bv" CONST (eval_int {{ `nBytes * 8 : [32] }});
  
  execute [bv.p];

  bytes <- list "bytes" CONST nBytes uint8_t;

  let List = (bv.List).c;
  let b = bytes.c;
  postcond {{ from_list`{b=nBytes*8} List == join b }};

  returns bytes.p;
};

bitvector_t_to_bytes_result <-
  bv_verify "bitvector_t_to_bytes" [] (bitvector_t_to_bytes_spec nBytes);


//bitvector_t *bitvector_t_concat(bitvector_t *x, bitvector_t *y)
let bitvector_t_concat_spec (nx : Int) (ny : Int) = do {
  x <- bitvector_t "x" CONST nx;
  y <- bitvector_t "y" CONST ny;

  execute [x.p, y.p];

  let n' = eval_int {{ `(nx + ny) : [32] }};

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (x_List, y_List, ret_List) = ((x.List).c, (y.List).c, (ret.List).c);
  postcond {{ (from_list`{b=nx} x_List) # (from_list`{b=ny} y_List) == (from_list`{b=n'} ret_List) }};

  crucible_return pret;
};

bitvector_t_concat_result <-
  bv_verify "bitvector_t_concat" [] (bitvector_t_concat_spec nBits nBits2);


let bitvector_t_negateUpdate_spec (n : Int) = do {
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  crucible_execute_func [pbv];

  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv;

  crucible_postcond {{ (from_list`{b=n} List) == ~(from_list`{b=n} List') }};
};

let bitvector_t_negate_spec (n : Int) = do {
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  crucible_execute_func [pbv];

  pbv' <- crucible_alloc (struct "bitvector_t");
  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv';
  crucible_return pbv';

  crucible_postcond {{ (from_list`{b=n} List) == ~(from_list`{b=n} List') }};
};

let bitvector_t_getBit_spec (n : Int) = do {
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  index <- uint32_t "index";
  crucible_precond {{ index < `n }};

  crucible_execute_func [pbv, crucible_term {{ index }}];

  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv;

  crucible_return (crucible_term {{ 0#[(from_list`{b=n} List)!index] : [8] }});
};

let bitvector_t_setBit_spec (n : Int) = do {
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  index <- uint32_t "index";
  crucible_precond {{ index < `n }};

  value <- uint8_t "value";

  crucible_execute_func [pbv, crucible_term {{ index }}, crucible_term {{ value }}];

  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv;

//  crucible_postcond
//    {{ (from_list`{b=n} List') == (updateEnd (from_list`{b=n} List) (index : [32]) (value!=0)) }};
  crucible_postcond {{ (from_list`{b=n} List')!index == (value!=0) }}; //Bit is set
  crucible_postcond {{ (from_list`{b=n} List') && ~(1<<index) ==       //Nothing else changed
                       (from_list`{b=n} List ) && ~(1<<index) }};
};

let bitvector_t_popcount_spec (n : Int) = do {
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  crucible_execute_func [pbv];

  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv;

  crucible_postcond {{ from_list`{b=n} List == from_list`{b=n} List' }};

  crucible_return (crucible_term {{ (popcount (from_list`{b=n} List)) : [32] }});
};

let bitvector_t_sliceUpdate_spec (n : Int) (start : Int) (length : Int) = do {
  (pslice, s_nBits, s_nLength, s_nLength_max, s_List, s_pList) <- bitvector_t length "slice";
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  crucible_execute_func [pslice, pbv, crucible_term {{ `start : [32] }}, crucible_term {{ `length : [32] }}];

  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv;

  crucible_postcond {{ List == List' }};

  (s_nBits', s_nLength', s_nLength_max', s_List', s_pList') <- bitvector_t' length "slice'" pslice;

  crucible_postcond {{ from_list s_List' == (from_list`{b=n} List)!!([start+length, start+length-1 .. start]:[_][32]) }};
};

let bitvector_t_slice_spec (n : Int) (start : Int) (length : Int) = do {
  (pbv, nBits, nLength, nLength_max, List, pList) <- bitvector_t n "bv";
  crucible_execute_func [pbv, crucible_term {{ `start : [32] }}, crucible_term {{ `length : [32] }}];

  (nBits', nLength', nLength_max', List', pList') <- bitvector_t' n "bv'" pbv;

  crucible_postcond {{ List == List' }};

  pslice <- crucible_alloc (struct "bitvector_t");
  (s_nBits, s_nLength, s_nLength_max, s_List, s_pList) <- bitvector_t' length "slice'" pslice;

  crucible_postcond {{ from_list s_List == (from_list`{b=n} List)!!([start+length, start+length-1 .. start]:[_][32]) }};

  crucible_return pslice;
};

let bitvector_t_xorUpdate_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};
  crucible_postcond {{ x_List' == x_List ^ y_List }};
};

let bitvector_t_xor_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ x_List' == x_List }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};

  presult <- crucible_alloc (struct "bitvector_t");
  (r_nBits, r_nLength, r_nLength_max, r_List, r_pList) <- bitvector_t' n "r" presult;

  crucible_return presult;

  crucible_postcond {{ r_List == x_List ^ y_List }};
};

let bitvector_t_orUpdate_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};
  crucible_postcond {{ x_List' == x_List || y_List }};
};

let bitvector_t_or_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ x_List' == x_List }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};

  presult <- crucible_alloc (struct "bitvector_t");
  (r_nBits, r_nLength, r_nLength_max, r_List, r_pList) <- bitvector_t' n "r" presult;

  crucible_return presult;

  crucible_postcond {{ r_List == x_List || y_List }};
};

let bitvector_t_andUpdate_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};
  crucible_postcond {{ x_List' == x_List && y_List }};
};

let bitvector_t_and_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ x_List' == x_List }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};

  presult <- crucible_alloc (struct "bitvector_t");
  (r_nBits, r_nLength, r_nLength_max, r_List, r_pList) <- bitvector_t' n "r" presult;

  crucible_return presult;

  crucible_postcond {{ r_List == x_List && y_List }};
};

let bitvector_t_equal_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ (from_list`{b=n} x_List) == (from_list`{b=n} x_List') }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ (from_list`{b=n} y_List) == (from_list`{b=n} y_List') }};

  crucible_return (crucible_term {{ 0 # [(from_list`{b=n} x_List) == (from_list`{b=n} y_List)] : [8] }});
};


bitvector_bc <- llvm_load_module "../obj/bitvector.bc";



bitvector_t_zeroize_result <- crucible_llvm_verify bitvector_bc "bitvector_t_zeroize" [] false (bitvector_t_zeroize_spec nBits) z3;

bitvector_t_alloc_result <- crucible_llvm_verify bitvector_bc "bitvector_t_alloc" [bitvector_t_zeroize_result] false (bitvector_t_alloc_spec nBits) z3;

bitvector_t_cleanHighBits_result <- crucible_llvm_verify bitvector_bc "bitvector_t_cleanHighBits" [] false (bitvector_t_cleanHighBits_spec nBits) z3;

bitvector_t_fromHexString_result <- crucible_llvm_verify bitvector_bc "bitvector_t_fromHexString" [] true (bitvector_t_fromHexString_spec nHexChars) z3;

bitvector_t_copyUpdate_result <- crucible_llvm_verify bitvector_bc "bitvector_t_copyUpdate" [] true (bitvector_t_copyUpdate_spec nBits) z3;

bitvector_t_copy_result <- crucible_llvm_verify bitvector_bc "bitvector_t_copy" [bitvector_t_copyUpdate_result] true (bitvector_t_copy_spec nBits) z3;

bitvector_t_widenUpdate_result <- crucible_llvm_verify bitvector_bc "bitvector_t_widenUpdate" [] true (bitvector_t_widenUpdate_spec nBits nBitsToAdd) z3;

bitvector_t_concat_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_concat" [bitvector_t_widenUpdate_result] true (bitvector_t_concat_spec nBits2 nBits) z3);

bitvector_t_negateUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_negateUpdate" [] true (bitvector_t_negateUpdate_spec nBits) z3);

bitvector_t_negate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_negate" [bitvector_t_negateUpdate_result] true (bitvector_t_negate_spec nBits) z3);

bitvector_t_dropUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_dropUpdate" [] true (bitvector_t_dropUpdate_spec nBits nBitsToDrop) z3);

bitvector_t_drop_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_drop" [] true (bitvector_t_drop_spec nBits nBitsToDrop) z3);

bitvector_t_getBit_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_getBit" [] true (bitvector_t_getBit_spec nBits) z3);

bitvector_t_setBit_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_setBit" [] true (bitvector_t_setBit_spec nBits) z3);

bitvector_t_popcount_result <- crucible_llvm_verify bitvector_bc "bitvector_t_popcount" [] true (bitvector_t_popcount_spec nBits) z3;

bitvector_t_sliceUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_sliceUpdate" [] true (bitvector_t_sliceUpdate_spec nBits slicestart slicelength) z3);

bitvector_t_slice_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_slice" [bitvector_t_sliceUpdate_result] true (bitvector_t_slice_spec nBits slicestart slicelength) z3);

bitvector_t_xorUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_xorUpdate" [] true (bitvector_t_xorUpdate_spec nBits) z3);

bitvector_t_xor_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_xor" [bitvector_t_xorUpdate_result] true (bitvector_t_xor_spec nBits) z3);

bitvector_t_orUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_orUpdate" [] true (bitvector_t_orUpdate_spec nBits) z3);

bitvector_t_or_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_or" [bitvector_t_orUpdate_result] true (bitvector_t_or_spec nBits) z3);

bitvector_t_andUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_andUpdate" [] true (bitvector_t_andUpdate_spec nBits) z3);

bitvector_t_and_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_and" [bitvector_t_andUpdate_result] true (bitvector_t_and_spec nBits) z3);

bitvector_t_equal_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_equal" [] true (bitvector_t_equal_spec nBits) z3);




