let CONST = {{ False }};
let WRITE = {{ True }};

let points_to = crucible_points_to;
let precond = crucible_precond;
let from_cryptol = crucible_term;
let execute = crucible_execute_func;
let postcond = crucible_postcond;
let returns = crucible_return;
let struct = crucible_struct;
let array = crucible_array;
let pointer rw type = if (eval_bool {{ rw == WRITE }})
                      then crucible_alloc type
                      else crucible_alloc_readonly type;

let uint64_t = llvm_int 64;
let uint32_t = llvm_int 32;
let uint16_t = llvm_int 16;
let uint8_t = llvm_int 8;
let struct_t struct_name = llvm_type (str_concat "%struct." struct_name);

let variable (name : String) (type : LLVMType) = do {
  cryptol_var <- crucible_fresh_var name type;
  return {s=from_cryptol cryptol_var, c=cryptol_var};
};

let alloc (name : String) (rw : Term) (type : LLVMType) = do {
  p <- pointer rw type;
  v <- variable name type;
  points_to p v.s;
  return {p=p, s=v.s, c=v.c};
};

let list (name : String) (rw : Term) (size : Int) (basetype : LLVMType) = do {
  let type = llvm_array size basetype;
  value <- alloc name rw type;
  return {p=value.p, s=value.s, c=value.c};
};

//Here the pointer points to a sting of size `size+1` that is NULL
//terminated. The Cryptol value does not have the NULL at the end of
//the string.
let string_t (string_name : String) (rw : Term) (size : Int) = do {
  string <- crucible_fresh_var string_name (llvm_array size uint8_t);
  pstring <- pointer rw (llvm_array (eval_int {{ `size + 1 : [64] }}) uint8_t);
  points_to pstring (from_cryptol {{ string # [0] }});
  return {p=pstring, s=from_cryptol string, c=string};
};

let string_t' (string_name : String) (size : Int) = do {
  string <- list "string" CONST (eval_int {{ `(size+1) : [64] }}) uint8_t;
  let s = string.c;
  postcond {{ s@(`size : [64]) == 0 }};
  return {p=string.p, s=from_cryptol string.c, c=string.c};
};

let error = do {
  crucible_precond {{ True }};
  crucible_postcond {{ True }};
  return {{ True }};
};

let noerror = do {
  return {{ True }};
};

let struct_list_empty = do {
  return {s=[] : [SetupValue], bucket=[] : [b]} : CrucibleSetup {s : [SetupValue], bucket : [b]};
};

rec struct_list_rec (numElements : Int) (init_function : Int -> a -> CrucibleSetup {s : SetupValue, bucket : b}) (params : a) = do {
  err <- if (eval_bool {{ (`numElements : [32]) == 0 }}) then error else noerror; //numElements must be greater than 0
  element <- init_function (eval_int {{ (`numElements : [32]) - 1 }}) params;
  rest <- if (eval_bool {{ (`numElements : [32]) == 1 }}) then struct_list_empty
          else struct_list_rec (eval_int {{ (`numElements : [32]) - 1 }}) init_function params;

  let ret_s = (concat rest.s [element.s]);
  let ret_bucket = (concat rest.bucket [element.bucket]);

  return {s=ret_s, bucket=ret_bucket};
};

let struct_list (rw : Term) (numElements : Int) (init_function : Int -> a -> CrucibleSetup {s : SetupValue, bucket : b}) (params : a) (type : LLVMType) = do {
  list <- struct_list_rec numElements init_function params;
  let arr = array list.s;
  p <- pointer rw (llvm_array numElements type);
  points_to p arr;
  return {p=p, s=arr, bucket=list.bucket};
};

let {{
  hexstring_to_bv : {a} (fin a) => [a][8] -> [a*4]
  hexstring_to_bv s =
    join [ drop (if (c >= 'a' /\ c <= 'f') then (c - 'a') + 10
                  | (c >= 'A' /\ c <= 'F') then (c - 'A') + 10
                  | (c >= '0' /\ c <= '9') then (c - '0')
                 else 0) : [4]
         | c <- s ]

  bv_to_hexstring : {a} (fin a) => [a*4] -> [a][8]
  bv_to_hexstring bv = [ (if d >= 10
                          then (0#d) + 'a' - 10
                          else (0#d) + '0')
                       | d <- groupBy`{4} bv ]

  hexstring_inverts x = hexstring_to_bv (bv_to_hexstring x) == x

  from_list : {a, b} (fin a, fin b, a*64 >= b) => [a][64] -> [b]
  from_list List = drop (join (reverse List))
  
  to_List bv = reverse(groupBy`{64} (0#bv))

  popcount : {a} (fin a) => [a] -> [32]
  popcount bs = counts!0
    where counts = [0] # [(0#[b]) + c | b <- bs | c <- counts]
}};

bitvector_bc <- llvm_load_module "../obj/bitvector.bc";

let bitvector_t_setup (name : String) (rw : Term) (n : Int) = do {
  let nLength = {{ `(n /^ 64) : [64] }};
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  List <- list (str_concat name ".bits->pList") rw (eval_int {{ `(n /^ 64) : [64] }}) uint64_t;
  let nBits = {{ `n : [32] }};
  let bv_struct = (struct [from_cryptol nBits,
                           struct [from_cryptol nLength,
                                   nLength_max.s,
                                   List.p]]);

  return {struct=bv_struct, nBits=nBits, nLength=nLength, nLength_max=nLength_max.c, List=List};
};

let bitvector_t (name : String) (rw : Term) (n : Int) = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  pbv <- pointer rw (struct_t "bitvector_t");
  points_to pbv bv.struct;

  return {p=pbv, struct=bv.struct, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t' (name : String) (n : Int) (pbv : SetupValue) = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  points_to pbv bv.struct;

  return {p=pbv, struct=bv.struct, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t_struct (_ : Int) (name : String, rw : Term, n : Int) = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  return {s=bv.struct, bucket=(bv.List).c};
};

let bitvector_t_struct' (_ : Int) (name : String, n : Int) = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  return {s=bv.struct, bucket=(bv.List).c};
};

let sequence_t (name : String) (rw : Term) (nLength : Int) (nBits : Int) = do {
  List <- struct_list rw nLength bitvector_t_struct (str_concat name ".pList", rw, nBits) (struct_t "bitvector_t");
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  let seq_struct = struct [ from_cryptol {{ `nLength : [64] }},
                            nLength_max.s,
                            List.p ];

  let nLength_max_c = nLength_max.c;
  precond {{ (nLength_max_c : [64]) >= (`nLength : [64])}};
  pseq <- pointer rw (struct_t "sequence_t");
  points_to pseq seq_struct;

  return {p=pseq, struct=seq_struct, nBits=from_cryptol {{ `nBits : [32] }}, nLength=from_cryptol {{ `nLength : [64] }}, nLength_max=nLength_max.c, List={s=List.s, c=list_term List.bucket}};
};

let sequence_t' (name : String) (nLength : Int) (nBits : Int) (pseq : SetupValue) = do {
  List <- struct_list CONST nLength bitvector_t_struct' (str_concat name ".pList", nBits) (struct_t "bitvector_t");

  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  let seq_struct = struct [ from_cryptol {{ `nLength : [64] }},
                            nLength_max.s,
                            List.p ];
  let nLength_max_c = nLength_max.c;
  postcond {{ (nLength_max_c : [64]) >= (`nLength : [64])}};
  points_to pseq seq_struct;

  return {p=pseq, struct=seq_struct, nBits=from_cryptol {{ `nBits : [32] }}, nLength=from_cryptol {{ `nLength : [64] }}, nLength_max=nLength_max.c, List={s=List.s, c=list_term List.bucket}};
};

let nBits = 200;
let nBits2 = 137;
let nBitsToAdd = 10;
let nBitsToDrop = 10;
let nHexChars = 17;
let nBytes = 23;
let slicestart = 54;
let slicelength = 113;

let bv_verify function_name overrides spec =
  crucible_llvm_verify bitvector_bc function_name overrides true spec z3;


//void bitvector_t_zeroize(bitvector_t *bv)
let bitvector_t_zeroize_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;

  let List' = (bv'.List).c;
  postcond {{ List' == (zero : [n /^ 64][64]) }};
};

bitvector_t_zeroize_result <-
  bv_verify "bitvector_t_zeroize" [] (bitvector_t_zeroize_spec nBits);


//bitvector_t *bitvector_t_alloc(uint32_t nBits)
let bitvector_t_alloc_spec (nBits : Int) = do {
  execute [from_cryptol {{ `nBits : [32] }}];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" nBits pbv;

  let List' = (bv'.List).c;
  postcond {{ List' == (zero : [nBits /^ 64][64]) }};

  returns pbv;
};

bitvector_t_alloc_result <-
  bv_verify "bitvector_t_alloc" [bitvector_t_zeroize_result] (bitvector_t_alloc_spec nBits);


//void bitvector_t_copyUpdate(bitvector_t *dst, bitvector_t *src)
let bitvector_t_copyUpdate_spec (n : Int) = do {
  dst <- bitvector_t "dst" WRITE n;
  src <- bitvector_t "src" CONST n;
  execute [dst.p, src.p];

  dst' <- bitvector_t' "dst'" n dst.p;

  let (s_List, d_List') = ((src.List).c, (dst'.List).c);
  postcond {{ s_List == d_List' }};
};

bitvector_t_copyUpdate_result <-
  bv_verify "bitvector_t_copyUpdate" [] (bitvector_t_copyUpdate_spec nBits);


//bitvector_t *bitvector_t_copy(bitvector_t *bv) {
let bitvector_t_copy_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p];

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n pret;
  let (List, ret_List) = ((bv.List).c, (ret.List).c);
  postcond {{ List == ret_List }};
  returns pret;
};

bitvector_t_copy_result <-
  bv_verify "bitvector_t_copy" [bitvector_t_copyUpdate_result] (bitvector_t_copy_spec nBits);


//void bitvector_t_cleanHighBits(bitvector_t *bv)
let bitvector_t_cleanHighBits_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;

  let (List, List') = ((bv.List).c, (bv'.List).c);
  postcond {{ (from_list List : [n]) == from_list List' }};
};

bitvector_t_cleanHighBits_result <-
  bv_verify "bitvector_t_cleanHighBits" [] (bitvector_t_cleanHighBits_spec 64);


//void bitvector_t_widenUpdate(bitvector_t *bv, uint32_t nBitsToAdd)
let bitvector_t_widenUpdate_spec (n : Int) (nBitsToAdd : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToAdd : [32] }}];

  let n' = eval_int {{ `(n + nBitsToAdd) : [32] }};

  bv' <- bitvector_t' "bv'" n' bv.p;

  let (List, List') = ((bv.List).c, (bv'.List).c);
  postcond {{ (0 # (from_list`{b=n} List)) == (from_list`{b=n'} List') }};
};

bitvector_t_widenUpdate_result <-
  bv_verify "bitvector_t_widenUpdate" [] (bitvector_t_widenUpdate_spec nBits nBitsToAdd);

//bitvector_t *bitvector_t_widen(bitvector_t *bv, uint32_t nBitsToAdd)
let bitvector_t_widen_spec (n : Int) (nBitsToAdd : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p, from_cryptol {{ `nBitsToAdd : [32] }}];

  let n' = eval_int {{ `(n + nBitsToAdd) : [32] }};

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (List, ret_List) = ((bv.List).c, (ret.List).c);
  postcond {{ (0 # (from_list`{b=n} List)) == (from_list`{b=n'} ret_List) }};
  returns pret;
};

bitvector_t_widen_result <-
  bv_verify "bitvector_t_widen" [bitvector_t_widenUpdate_result] (bitvector_t_widen_spec nBits nBitsToAdd);


//bitvector_t *bitvector_t_fromHexString(char *string)
let bitvector_t_fromHexString_spec (n : Int) = do {
  string <- string_t "string" CONST n;

  let s = string.c;
  precond {{ [ (c >= 'a' /\ c <= 'f') \/
               (c >= 'A' /\ c <= 'F') \/
               (c >= '0' /\ c <= '9')
	     | c <- s ] == ~zero }};

  execute [string.p];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" (eval_int {{ `(n*4) : [64] }}) pbv;

  let List' = (bv'.List).c;
  postcond {{ hexstring_to_bv s == from_list List' }};

  returns pbv;
};

bitvector_t_fromHexString_result <-
  bv_verify "bitvector_t_fromHexString" [] (bitvector_t_fromHexString_spec nHexChars);


//char *bitvector_t_toHexString(bitvector_t *bv)
let bitvector_t_toHexString_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE (eval_int {{ `(n*4) : [64] }});

  execute [bv.p];

  string <- string_t' "string" n;

  let (s, List) = (string.c, (bv.List).c);
  postcond {{ bv_to_hexstring`{n} (from_list List) == take s }};

  returns string.p;
};

bitvector_t_toHexString_result <-
  bv_verify "bitvector_t_toHexString" [] (bitvector_t_toHexString_spec nHexChars);


//void bitvector_t_dropUpdate(bitvector_t *bv, uint32_t nBitsToDrop)
let bitvector_t_dropUpdate_spec (n : Int) (nBitsToDrop : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToDrop : [32] }}];

  let n' = eval_int {{ `(n - nBitsToDrop) : [32] }};

  bv' <- bitvector_t' "bv'" n' bv.p;

  let (List, List') = ((bv.List).c, (bv'.List).c);
  postcond {{ drop`{nBitsToDrop} (from_list`{b=n} List) == (from_list`{b=n'} List') }};
};

bitvector_t_dropUpdate_result <-
  bv_verify "bitvector_t_dropUpdate" [] (bitvector_t_dropUpdate_spec nBits nBitsToDrop);
  

//bitvector_t *bitvector_t_drop(bitvector_t *bv, uint32_t nBitsToDrop) {
let bitvector_t_drop_spec (n : Int) (nBitsToDrop : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToDrop : [32] }}];

  //Show that nBits and nLength of the input bv were unchanged
  bv' <- bitvector_t' "bv'" n bv.p;

  let (nBits, nBits') = (bv.nBits, bv'.nBits);
  postcond {{ (nBits : [32]) == (nBits' : [32]) }};

  let (nLength, nLength') = (bv.nLength, bv'.nLength);
  postcond {{ (nLength : [64]) == (nLength' : [64]) }};

  //Show that the result bv is correct
  let n' = eval_int {{ `(n - nBitsToDrop) : [32] }};
  
  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (List, ret_List) = ((bv.List).c, (ret.List).c);
  postcond {{ drop`{nBitsToDrop} (from_list`{b=n} List) == (from_list`{b=n'} ret_List) }};

  returns pret;
};

bitvector_t_drop_result <-
  bv_verify "bitvector_t_drop" [] (bitvector_t_drop_spec nBits nBitsToDrop);


//void bitvector_t_from_bytes(bitvector_t *bv, uint8_t *bytes, uint32_t nBytes)
let bitvector_t_from_bytes_spec (n : Int) (nBytes : Int) = do {
  bytes <- list "bytes" CONST nBytes uint8_t;

  execute [bytes.p, from_cryptol {{ `nBytes : [32] }}];

  let n' = eval_int {{ `(nBytes * 8) : [32] }};

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" n' pbv;

  let List = (bv'.List).c;
  let b = bytes.c;
  postcond {{ from_list`{b=n'} List == join b }};

  returns pbv;
};

bitvector_t_from_bytes_result <-
  bv_verify "bitvector_t_from_bytes" [bitvector_t_widenUpdate_result] (bitvector_t_from_bytes_spec nBits nBytes);


//uint8_t *bitvector_t_to_bytes(bitvector_t *bv)
let bitvector_t_to_bytes_spec (nBytes : Int) = do {
  bv <- bitvector_t "bv" CONST (eval_int {{ `nBytes * 8 : [32] }});
  
  execute [bv.p];

  bytes <- list "bytes" CONST nBytes uint8_t;

  let List = (bv.List).c;
  let b = bytes.c;
  postcond {{ from_list`{b=nBytes*8} List == join b }};

  returns bytes.p;
};

bitvector_t_to_bytes_result <-
  bv_verify "bitvector_t_to_bytes" [] (bitvector_t_to_bytes_spec nBytes);


//bitvector_t *bitvector_t_concat(bitvector_t *x, bitvector_t *y)
let bitvector_t_concat_spec (nx : Int) (ny : Int) = do {
  x <- bitvector_t "x" CONST nx;
  y <- bitvector_t "y" CONST ny;

  execute [x.p, y.p];

  let n' = eval_int {{ `(nx + ny) : [32] }};

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (x_List, y_List, ret_List) = ((x.List).c, (y.List).c, (ret.List).c);
  postcond {{ (from_list`{b=nx} x_List) # (from_list`{b=ny} y_List) == (from_list`{b=n'} ret_List) }};

  returns pret;
};

bitvector_t_concat_result <-
  bv_verify "bitvector_t_concat" [] (bitvector_t_concat_spec 64 64);


//void bitvector_t_negateUpdate(bitvector_t *bv)
let bitvector_t_negateUpdate_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;
  let (List, List') = ((bv.List).c, (bv'.List).c);

  postcond {{ (from_list`{b=n} List) == ~(from_list`{b=n} List') }};
};

bitvector_t_negateUpdate_result <-
  bv_verify "bitvector_t_negateUpdate" [] (bitvector_t_negateUpdate_spec nBits);


//bitvector_t *bitvector_t_negate(bitvector_t *bv)
let bitvector_t_negate_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p];

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n pret;

  let (List, ret_List) = ((bv.List).c, (ret.List).c);
  postcond {{ (from_list`{b=n} List) == ~(from_list`{b=n} ret_List) }};

  returns pret;
};

bitvector_t_negate_result <-
  bv_verify "bitvector_t_negate" [] (bitvector_t_negate_spec nBits);
  

//uint8_t bitvector_t_getBit(bitvector_t *bv, uint32_t index)
let bitvector_t_getBit_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  index <- variable "index" uint32_t;
  let index_c = index.c;
  precond {{ index_c < `n }};

  execute [bv.p, index.s];

  let List = (bv.List).c;
  returns (from_cryptol {{ 0#[(from_list`{b=n} List)!index_c] : [8] }});
};

bitvector_t_getBit_result <-
  bv_verify "bitvector_t_getBit" [] (bitvector_t_getBit_spec nBits);


//void bitvector_t_setBit(bitvector_t *bv, uint32_t index, uint8_t value)
let bitvector_t_setBit_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  index <- variable "index" uint32_t;
  let index_c = index.c;
  precond {{ index_c < `n }};

  value <- variable "value" uint8_t;
  let value_c = value.c;

  execute [bv.p, index.s, value.s];

  bv' <- bitvector_t' "bv'" n bv.p;
  let (List, List') = ((bv.List).c, (bv'.List).c);    

  postcond {{ updateEnd (from_list`{b=n} List) index_c (value_c!=0) == from_list`{b=n} List' }};
};

bitvector_t_setBit_result <-
  bv_verify "bitvector_t_setBit" [] (bitvector_t_setBit_spec nBits);


//uint32_t bitvector_t_popcount(bitvector_t *bv)
let bitvector_t_popcount_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;
  execute [bv.p];

  let List = (bv.List).c;

  returns (from_cryptol {{ (popcount (from_list`{b=n} List)) : [32] }});
};

bitvector_t_popcount_result <-
  bv_verify "bitvector_t_popcount" [] (bitvector_t_popcount_spec nBits);


//void bitvector_t_sliceUpdate(bitvector_t *slice, bitvector_t *bv, uint32_t start, uint32_t length)
let bitvector_t_sliceUpdate_spec (n : Int) (start : Int) (length : Int) = do {
  slice <- bitvector_t "slice" WRITE length;
  bv <- bitvector_t "bv" CONST n;
  
  execute [slice.p, bv.p, from_cryptol {{ `start : [32] }}, from_cryptol {{ `length : [32] }}];

  slice' <- bitvector_t' "slice'" length slice.p;
  let (List, s_List') = ((bv.List).c, (slice'.List).c);

  postcond {{ from_list`{b=length} s_List' == (from_list`{b=n} List)!!([start+length-1, start+length-2 .. start]:[length][32]) }};
};

bitvector_t_sliceUpdate_result <-
  bv_verify "bitvector_t_sliceUpdate" [] (bitvector_t_sliceUpdate_spec nBits slicestart slicelength);


//bitvector_t *bitvector_t_slice(bitvector_t *bv, uint32_t start, uint32_t length)
let bitvector_t_slice_spec (n : Int) (start : Int) (length : Int) = do {
  bv <- bitvector_t "bv" CONST n;
  
  execute [bv.p, from_cryptol {{ `start : [32] }}, from_cryptol {{ `length : [32] }}];

  pslice <- pointer CONST (struct_t "bitvector_t");
  slice' <- bitvector_t' "slice'" length pslice;
  let (List, s_List') = ((bv.List).c, (slice'.List).c);

  postcond {{ from_list`{b=length} s_List' == (from_list`{b=n} List)!!([start+length-1, start+length-2 .. start]:[length][32]) }};

  returns pslice;
};

bitvector_t_slice_result <-
  bv_verify "bitvector_t_slice" [] (bitvector_t_slice_spec nBits slicestart slicelength);


//sequence_t *bitvector_t_split(bitvector_t *bv, uint32_t parts)
let bitvector_t_split_spec (n : Int) (parts : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `parts : [32] }}];

  pseq <- pointer CONST (struct_t "sequence_t");
//  seq <- sequence_t' "sequence" parts n pseq;

//  let List_seq = (seq.List).c;
//  let List_bv = (bv.List).c;

//  postcond {{ split`{parts=parts} (from_list`{b=n} List_bv) == [ from_list`{b=n/parts} List_seqi | List_seqi <- List_seq ] }};

  returns pseq;
};

bitvector_t_split_result <-
  bv_verify "bitvector_t_split" [] (bitvector_t_split_spec 128 2);
  

//bitvector_t *sequence_t_join(sequence_t *sequence)
let sequence_t_join_spec (n : Int) (parts : Int) = do {
  seq <- sequence_t "seq" CONST parts n;

  execute [seq.p];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv <- bitvector_t' "bv" (eval_int {{ (`n : [32]) * `parts }}) pbv;
  let List_bv = (bv.List).c;
  let List_seq = (seq.List).c;
  
  postcond {{ join [ from_list`{b=n} List_seqi | List_seqi <- List_seq] == (from_list`{b=n*parts} List_bv) }};

  returns pbv;
};

sequence_t_join_result <-
  bv_verify "sequence_t_join" [] (sequence_t_join_spec 64 2);


//uint8_t bitvector_t_equal(bitvector_t *x, bitvector_t *y)
let bitvector_t_equal_spec (n : Int) = do {
  x <- bitvector_t "x" WRITE n;
  y <- bitvector_t "y" WRITE n;

  execute [x.p, y.p];

  let (xList, yList) = ((x.List).c, (y.List).c);

  returns (from_cryptol {{ if (from_list`{b=n} xList) == (from_list`{b=n} yList) then 1 else 0 : [8]}} );
};

bitvector_t_equal_result <-
  bv_verify "bitvector_t_equal" [] (bitvector_t_equal_spec nBits);


let bitvector_t_xorUpdate_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};
  crucible_postcond {{ x_List' == x_List ^ y_List }};
};

let bitvector_t_xor_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ x_List' == x_List }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};

  presult <- crucible_alloc (struct "bitvector_t");
  (r_nBits, r_nLength, r_nLength_max, r_List, r_pList) <- bitvector_t' n "r" presult;

  crucible_return presult;

  crucible_postcond {{ r_List == x_List ^ y_List }};
};

let bitvector_t_orUpdate_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};
  crucible_postcond {{ x_List' == x_List || y_List }};
};

let bitvector_t_or_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ x_List' == x_List }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};

  presult <- crucible_alloc (struct "bitvector_t");
  (r_nBits, r_nLength, r_nLength_max, r_List, r_pList) <- bitvector_t' n "r" presult;

  crucible_return presult;

  crucible_postcond {{ r_List == x_List || y_List }};
};

let bitvector_t_andUpdate_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};
  crucible_postcond {{ x_List' == x_List && y_List }};
};

let bitvector_t_and_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ x_List' == x_List }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ y_List' == y_List }};

  presult <- crucible_alloc (struct "bitvector_t");
  (r_nBits, r_nLength, r_nLength_max, r_List, r_pList) <- bitvector_t' n "r" presult;

  crucible_return presult;

  crucible_postcond {{ r_List == x_List && y_List }};
};

let bitvector_t_equal_spec (n : Int) = do {
  (px, x_nBits, x_nLength, x_nLength_max, x_List, x_pList) <- bitvector_t n "x";
  (py, y_nBits, y_nLength, y_nLength_max, y_List, y_pList) <- bitvector_t n "y";
  crucible_execute_func [px, py];

  (x_nBits', x_nLength', x_nLength_max', x_List', x_pList') <- bitvector_t' n "x'" px;

  crucible_postcond {{ (from_list`{b=n} x_List) == (from_list`{b=n} x_List') }};
  
  (y_nBits', y_nLength', y_nLength_max', y_List', y_pList') <- bitvector_t' n "y'" py;

  crucible_postcond {{ (from_list`{b=n} y_List) == (from_list`{b=n} y_List') }};

  crucible_return (crucible_term {{ 0 # [(from_list`{b=n} x_List) == (from_list`{b=n} y_List)] : [8] }});
};


bitvector_bc <- llvm_load_module "../obj/bitvector.bc";



bitvector_t_zeroize_result <- crucible_llvm_verify bitvector_bc "bitvector_t_zeroize" [] false (bitvector_t_zeroize_spec nBits) z3;

bitvector_t_alloc_result <- crucible_llvm_verify bitvector_bc "bitvector_t_alloc" [bitvector_t_zeroize_result] false (bitvector_t_alloc_spec nBits) z3;

bitvector_t_cleanHighBits_result <- crucible_llvm_verify bitvector_bc "bitvector_t_cleanHighBits" [] false (bitvector_t_cleanHighBits_spec nBits) z3;

bitvector_t_fromHexString_result <- crucible_llvm_verify bitvector_bc "bitvector_t_fromHexString" [] true (bitvector_t_fromHexString_spec nHexChars) z3;

bitvector_t_copyUpdate_result <- crucible_llvm_verify bitvector_bc "bitvector_t_copyUpdate" [] true (bitvector_t_copyUpdate_spec nBits) z3;

bitvector_t_copy_result <- crucible_llvm_verify bitvector_bc "bitvector_t_copy" [bitvector_t_copyUpdate_result] true (bitvector_t_copy_spec nBits) z3;

bitvector_t_widenUpdate_result <- crucible_llvm_verify bitvector_bc "bitvector_t_widenUpdate" [] true (bitvector_t_widenUpdate_spec nBits nBitsToAdd) z3;

bitvector_t_concat_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_concat" [bitvector_t_widenUpdate_result] true (bitvector_t_concat_spec nBits2 nBits) z3);

bitvector_t_negateUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_negateUpdate" [] true (bitvector_t_negateUpdate_spec nBits) z3);

bitvector_t_negate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_negate" [bitvector_t_negateUpdate_result] true (bitvector_t_negate_spec nBits) z3);

bitvector_t_dropUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_dropUpdate" [] true (bitvector_t_dropUpdate_spec nBits nBitsToDrop) z3);

bitvector_t_drop_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_drop" [] true (bitvector_t_drop_spec nBits nBitsToDrop) z3);

bitvector_t_getBit_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_getBit" [] true (bitvector_t_getBit_spec nBits) z3);

bitvector_t_setBit_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_setBit" [] true (bitvector_t_setBit_spec nBits) z3);

bitvector_t_popcount_result <- crucible_llvm_verify bitvector_bc "bitvector_t_popcount" [] true (bitvector_t_popcount_spec nBits) z3;

bitvector_t_sliceUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_sliceUpdate" [] true (bitvector_t_sliceUpdate_spec nBits slicestart slicelength) z3);

bitvector_t_slice_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_slice" [bitvector_t_sliceUpdate_result] true (bitvector_t_slice_spec nBits slicestart slicelength) z3);

bitvector_t_xorUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_xorUpdate" [] true (bitvector_t_xorUpdate_spec nBits) z3);

bitvector_t_xor_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_xor" [bitvector_t_xorUpdate_result] true (bitvector_t_xor_spec nBits) z3);

bitvector_t_orUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_orUpdate" [] true (bitvector_t_orUpdate_spec nBits) z3);

bitvector_t_or_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_or" [bitvector_t_orUpdate_result] true (bitvector_t_or_spec nBits) z3);

bitvector_t_andUpdate_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_andUpdate" [] true (bitvector_t_andUpdate_spec nBits) z3);

bitvector_t_and_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_and" [bitvector_t_andUpdate_result] true (bitvector_t_and_spec nBits) z3);

bitvector_t_equal_result <- (crucible_llvm_verify bitvector_bc "bitvector_t_equal" [] true (bitvector_t_equal_spec nBits) z3);




