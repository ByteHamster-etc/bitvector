include "llvm.saw";

let {{
  hexstring_to_bv : {a} (fin a) => [a][8] -> [a*4]
  hexstring_to_bv s =
    join [ drop (if (c >= 'a' /\ c <= 'f') then (c - 'a') + 10
                  | (c >= 'A' /\ c <= 'F') then (c - 'A') + 10
                  | (c >= '0' /\ c <= '9') then (c - '0')
                 else 0) : [4]
         | c <- s ]

  bv_to_hexstring : {a} (fin a) => [a*4] -> [a][8]
  bv_to_hexstring bv = [ (if d >= 10
                          then (0#d) + 'a' - 10
                          else (0#d) + '0')
                       | d <- groupBy`{4} bv ]

  hexstring_inverts x = hexstring_to_bv (bv_to_hexstring x) == x

  from_list : {a, b} (fin a, fin b, a*64 >= b) => [a][64] -> [b]
  from_list List = drop (join (reverse List))
  
  to_List bv = reverse(groupBy`{64} (0#bv))

  popcount : {a} (fin a) => [a] -> [32]
  popcount bs = counts!0
    where counts = [0] # [(0#[b]) + c | b <- bs | c <- counts]
}};

bitvector_bc <- llvm_load_module "../obj/bitvector.bc";

let bitvector_t_setup (name : String) (rw : Term) (n : Int) = do {
  let nLength = {{ `(n /^ 64) : [64] }};
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  List <- alloc (str_concat name ".bits->pList") rw (llvm_array (eval_int {{ `(n /^ 64) : [64] }}) uint64_t);
  let nBits = {{ `n : [32] }};
  let bv_struct = (struct [from_cryptol nBits,
                           struct [from_cryptol nLength,
                                   nLength_max.s,
                                   List.p]]);

  return {struct=bv_struct, nBits=nBits, nLength=nLength, nLength_max=nLength_max.t, List=List};
};

let bitvector_t (name : String) (rw : Term) (n : Int) = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  pbv <- pointer rw (struct_t "bitvector_t");
  points_to pbv bv.struct;

  return {p=pbv, struct=bv.struct, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t' (name : String) (n : Int) (pbv : SetupValue) = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  points_to pbv bv.struct;

  return {p=pbv, struct=bv.struct, nBits=bv.nBits, nLength=bv.nLength, nLength_max=bv.nLength_max, List=bv.List};
};

let bitvector_t_struct (_ : Int) (name : String, rw : Term, n : Int) = do {
  bv <- bitvector_t_setup name rw n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  precond {{ nLength_max >= nLength }};
  return {s=bv.struct, bucket=(bv.List).t};
};

let bitvector_t_struct' (_ : Int) (name : String, n : Int) = do {
  bv <- bitvector_t_setup name CONST n;
  let (nLength, nLength_max) = (bv.nLength, bv.nLength_max);
  postcond {{ nLength_max >= nLength }};
  return {s=bv.struct, bucket=(bv.List).t};
};

let sequence_t (name : String) (rw : Term) (nLength : Int) (nBits : Int) = do {
  List <- struct_array rw nLength bitvector_t_struct (str_concat name ".pList", rw, nBits) (struct_t "bitvector_t");
  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  let seq_struct = struct [ from_cryptol {{ `nLength : [64] }},
                            nLength_max.s,
                            List.p ];

  let nLength_max_c = nLength_max.t;
  precond {{ (nLength_max_c : [64]) >= (`nLength : [64])}};
  pseq <- pointer rw (struct_t "sequence_t");
  points_to pseq seq_struct;

  return {p=pseq, struct=seq_struct, nBits=from_cryptol {{ `nBits : [32] }}, nLength=from_cryptol {{ `nLength : [64] }}, nLength_max=nLength_max.t, List={s=List.s, t=list_term List.bucket}};
};

let sequence_t' (name : String) (nLength : Int) (nBits : Int) (pseq : SetupValue) = do {
  List <- struct_array CONST nLength bitvector_t_struct' (str_concat name ".pList", nBits) (struct_t "bitvector_t");

  nLength_max <- variable (str_concat name ".nLength_max") uint64_t;
  let seq_struct = struct [ from_cryptol {{ `nLength : [64] }},
                            nLength_max.s,
                            List.p ];
  let nLength_max_c = nLength_max.t;
  postcond {{ (nLength_max_c : [64]) >= (`nLength : [64])}};
  points_to pseq seq_struct;

  return {p=pseq, struct=seq_struct, nBits=from_cryptol {{ `nBits : [32] }}, nLength=from_cryptol {{ `nLength : [64] }}, nLength_max=nLength_max.t, List={s=List.s, t=list_term List.bucket}};
};

let nBits = 200;
let nBits2 = 137;
let nBitsToAdd = 10;
let nBitsToDrop = 10;
let nHexChars = 17;
let nBytes = 23;
let slicestart = 54;
let slicelength = 113;

let bv_verify function_name overrides spec =
  crucible_llvm_verify bitvector_bc function_name overrides true spec z3;


//void bitvector_t_zeroize(bitvector_t *bv)
let bitvector_t_zeroize_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;

  let List' = (bv'.List).t;
  postcond {{ List' == (zero : [n /^ 64][64]) }};
};

bitvector_t_zeroize_result <-
  bv_verify "bitvector_t_zeroize" [] (bitvector_t_zeroize_spec nBits);


//bitvector_t *bitvector_t_alloc(uint32_t nBits)
let bitvector_t_alloc_spec (nBits : Int) = do {
  execute [from_cryptol {{ `nBits : [32] }}];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" nBits pbv;

  let List' = (bv'.List).t;
  postcond {{ List' == (zero : [nBits /^ 64][64]) }};

  returns pbv;
};

bitvector_t_alloc_result <-
  bv_verify "bitvector_t_alloc" [bitvector_t_zeroize_result] (bitvector_t_alloc_spec nBits);


//void bitvector_t_copyUpdate(bitvector_t *dst, bitvector_t *src)
let bitvector_t_copyUpdate_spec (n : Int) = do {
  dst <- bitvector_t "dst" WRITE n;
  src <- bitvector_t "src" CONST n;
  execute [dst.p, src.p];

  dst' <- bitvector_t' "dst'" n dst.p;

  let (s_List, d_List') = ((src.List).t, (dst'.List).t);
  postcond {{ s_List == d_List' }};
};

bitvector_t_copyUpdate_result <-
  bv_verify "bitvector_t_copyUpdate" [] (bitvector_t_copyUpdate_spec nBits);


//bitvector_t *bitvector_t_copy(bitvector_t *bv) {
let bitvector_t_copy_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p];

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n pret;
  let (List, ret_List) = ((bv.List).t, (ret.List).t);
  postcond {{ List == ret_List }};
  returns pret;
};

bitvector_t_copy_result <-
  bv_verify "bitvector_t_copy" [bitvector_t_copyUpdate_result] (bitvector_t_copy_spec nBits);


//void bitvector_t_cleanHighBits(bitvector_t *bv)
let bitvector_t_cleanHighBits_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;

  let (List, List') = ((bv.List).t, (bv'.List).t);
  postcond {{ (from_list List : [n]) == from_list List' }};
};

bitvector_t_cleanHighBits_result <-
  bv_verify "bitvector_t_cleanHighBits" [] (bitvector_t_cleanHighBits_spec 64);


//void bitvector_t_widenUpdate(bitvector_t *bv, uint32_t nBitsToAdd)
let bitvector_t_widenUpdate_spec (n : Int) (nBitsToAdd : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToAdd : [32] }}];

  let n' = eval_int {{ `(n + nBitsToAdd) : [32] }};

  bv' <- bitvector_t' "bv'" n' bv.p;

  let (List, List') = ((bv.List).t, (bv'.List).t);
  postcond {{ (0 # (from_list`{b=n} List)) == (from_list`{b=n'} List') }};
};

bitvector_t_widenUpdate_result <-
  bv_verify "bitvector_t_widenUpdate" [] (bitvector_t_widenUpdate_spec nBits nBitsToAdd);

//bitvector_t *bitvector_t_widen(bitvector_t *bv, uint32_t nBitsToAdd)
let bitvector_t_widen_spec (n : Int) (nBitsToAdd : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p, from_cryptol {{ `nBitsToAdd : [32] }}];

  let n' = eval_int {{ `(n + nBitsToAdd) : [32] }};

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (List, ret_List) = ((bv.List).t, (ret.List).t);
  postcond {{ (0 # (from_list`{b=n} List)) == (from_list`{b=n'} ret_List) }};
  returns pret;
};

bitvector_t_widen_result <-
  bv_verify "bitvector_t_widen" [bitvector_t_widenUpdate_result] (bitvector_t_widen_spec nBits nBitsToAdd);


//bitvector_t *bitvector_t_fromHexString(char *string)
let bitvector_t_fromHexString_spec (n : Int) = do {
  string <- string_t "string" CONST n;

  let s = string.t;
  precond {{ [ (c >= 'a' /\ c <= 'f') \/
               (c >= 'A' /\ c <= 'F') \/
               (c >= '0' /\ c <= '9')
	     | c <- s ] == ~zero }};

  execute [string.p];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" (eval_int {{ `(n*4) : [64] }}) pbv;

  let List' = (bv'.List).t;
  postcond {{ hexstring_to_bv s == from_list List' }};

  returns pbv;
};

bitvector_t_fromHexString_result <-
  bv_verify "bitvector_t_fromHexString" [] (bitvector_t_fromHexString_spec nHexChars);


//char *bitvector_t_toHexString(bitvector_t *bv)
let bitvector_t_toHexString_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE (eval_int {{ `(n*4) : [64] }});

  execute [bv.p];

  string <- string_t' "string" n;

  let (s, List) = (string.t, (bv.List).t);
  postcond {{ bv_to_hexstring`{n} (from_list List) == take s }};

  returns string.p;
};

bitvector_t_toHexString_result <-
  bv_verify "bitvector_t_toHexString" [] (bitvector_t_toHexString_spec nHexChars);


//void bitvector_t_dropUpdate(bitvector_t *bv, uint32_t nBitsToDrop)
let bitvector_t_dropUpdate_spec (n : Int) (nBitsToDrop : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToDrop : [32] }}];

  let n' = eval_int {{ `(n - nBitsToDrop) : [32] }};

  bv' <- bitvector_t' "bv'" n' bv.p;

  let (List, List') = ((bv.List).t, (bv'.List).t);
  postcond {{ drop`{nBitsToDrop} (from_list`{b=n} List) == (from_list`{b=n'} List') }};
};

bitvector_t_dropUpdate_result <-
  bv_verify "bitvector_t_dropUpdate" [] (bitvector_t_dropUpdate_spec nBits nBitsToDrop);
  

//bitvector_t *bitvector_t_drop(bitvector_t *bv, uint32_t nBitsToDrop) {
let bitvector_t_drop_spec (n : Int) (nBitsToDrop : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `nBitsToDrop : [32] }}];

  //Show that nBits and nLength of the input bv were unchanged
  bv' <- bitvector_t' "bv'" n bv.p;

  let (nBits, nBits') = (bv.nBits, bv'.nBits);
  postcond {{ (nBits : [32]) == (nBits' : [32]) }};

  let (nLength, nLength') = (bv.nLength, bv'.nLength);
  postcond {{ (nLength : [64]) == (nLength' : [64]) }};

  //Show that the result bv is correct
  let n' = eval_int {{ `(n - nBitsToDrop) : [32] }};
  
  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (List, ret_List) = ((bv.List).t, (ret.List).t);
  postcond {{ drop`{nBitsToDrop} (from_list`{b=n} List) == (from_list`{b=n'} ret_List) }};

  returns pret;
};

bitvector_t_drop_result <-
  bv_verify "bitvector_t_drop" [] (bitvector_t_drop_spec nBits nBitsToDrop);


//void bitvector_t_from_bytes(bitvector_t *bv, uint8_t *bytes, uint32_t nBytes)
let bitvector_t_from_bytes_spec (n : Int) (nBytes : Int) = do {
  bytes <- alloc "bytes" CONST (llvm_array nBytes uint8_t);

  execute [bytes.p, from_cryptol {{ `nBytes : [32] }}];

  let n' = eval_int {{ `(nBytes * 8) : [32] }};

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv' <- bitvector_t' "bv'" n' pbv;

  let List = (bv'.List).t;
  let b = bytes.t;
  postcond {{ from_list`{b=n'} List == join b }};

  returns pbv;
};

bitvector_t_from_bytes_result <-
  bv_verify "bitvector_t_from_bytes" [bitvector_t_widenUpdate_result] (bitvector_t_from_bytes_spec nBits nBytes);


//uint8_t *bitvector_t_to_bytes(bitvector_t *bv)
let bitvector_t_to_bytes_spec (nBytes : Int) = do {
  bv <- bitvector_t "bv" CONST (eval_int {{ `nBytes * 8 : [32] }});
  
  execute [bv.p];

  bytes <- alloc "bytes" CONST (llvm_array nBytes uint8_t);

  let List = (bv.List).t;
  let b = bytes.t;
  postcond {{ from_list`{b=nBytes*8} List == join b }};

  returns bytes.p;
};

bitvector_t_to_bytes_result <-
  bv_verify "bitvector_t_to_bytes" [] (bitvector_t_to_bytes_spec nBytes);


//bitvector_t *bitvector_t_concat(bitvector_t *x, bitvector_t *y)
let bitvector_t_concat_spec (nx : Int) (ny : Int) = do {
  x <- bitvector_t "x" CONST nx;
  y <- bitvector_t "y" CONST ny;

  execute [x.p, y.p];

  let n' = eval_int {{ `(nx + ny) : [32] }};

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n' pret;

  let (x_List, y_List, ret_List) = ((x.List).t, (y.List).t, (ret.List).t);
  postcond {{ (from_list`{b=nx} x_List) # (from_list`{b=ny} y_List) == (from_list`{b=n'} ret_List) }};

  returns pret;
};

bitvector_t_concat_result <-
  bv_verify "bitvector_t_concat" [] (bitvector_t_concat_spec 64 64);


//void bitvector_t_negateUpdate(bitvector_t *bv)
let bitvector_t_negateUpdate_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p];

  bv' <- bitvector_t' "bv'" n bv.p;
  let (List, List') = ((bv.List).t, (bv'.List).t);

  postcond {{ (from_list`{b=n} List) == ~(from_list`{b=n} List') }};
};

bitvector_t_negateUpdate_result <-
  bv_verify "bitvector_t_negateUpdate" [] (bitvector_t_negateUpdate_spec nBits);


//bitvector_t *bitvector_t_negate(bitvector_t *bv)
let bitvector_t_negate_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  execute [bv.p];

  pret <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "ret" n pret;

  let (List, ret_List) = ((bv.List).t, (ret.List).t);
  postcond {{ (from_list`{b=n} List) == ~(from_list`{b=n} ret_List) }};

  returns pret;
};

bitvector_t_negate_result <-
  bv_verify "bitvector_t_negate" [] (bitvector_t_negate_spec nBits);
  

//uint8_t bitvector_t_getBit(bitvector_t *bv, uint32_t index)
let bitvector_t_getBit_spec (n : Int) = do {
  bv <- bitvector_t "bv" CONST n;

  index <- variable "index" uint32_t;
  let index_c = index.t;
  precond {{ index_c < `n }};

  execute [bv.p, index.s];

  let List = (bv.List).t;
  returns (from_cryptol {{ 0#[(from_list`{b=n} List)!index_c] : [8] }});
};

bitvector_t_getBit_result <-
  bv_verify "bitvector_t_getBit" [] (bitvector_t_getBit_spec nBits);


//void bitvector_t_setBit(bitvector_t *bv, uint32_t index, uint8_t value)
let bitvector_t_setBit_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  index <- variable "index" uint32_t;
  let index_c = index.t;
  precond {{ index_c < `n }};

  value <- variable "value" uint8_t;
  let value_c = value.t;

  execute [bv.p, index.s, value.s];

  bv' <- bitvector_t' "bv'" n bv.p;
  let (List, List') = ((bv.List).t, (bv'.List).t);    

  postcond {{ updateEnd (from_list`{b=n} List) index_c (value_c!=0) == from_list`{b=n} List' }};
};

bitvector_t_setBit_result <-
  bv_verify "bitvector_t_setBit" [] (bitvector_t_setBit_spec nBits);


//uint32_t bitvector_t_popcount(bitvector_t *bv)
let bitvector_t_popcount_spec (n : Int) = do {
  bv <- bitvector_t "bv" WRITE n;
  execute [bv.p];

  let List = (bv.List).t;

  returns (from_cryptol {{ (popcount (from_list`{b=n} List)) : [32] }});
};

bitvector_t_popcount_result <-
  bv_verify "bitvector_t_popcount" [] (bitvector_t_popcount_spec nBits);


//void bitvector_t_sliceUpdate(bitvector_t *slice, bitvector_t *bv, uint32_t start, uint32_t length)
let bitvector_t_sliceUpdate_spec (n : Int) (start : Int) (length : Int) = do {
  slice <- bitvector_t "slice" WRITE length;
  bv <- bitvector_t "bv" CONST n;
  
  execute [slice.p, bv.p, from_cryptol {{ `start : [32] }}, from_cryptol {{ `length : [32] }}];

  slice' <- bitvector_t' "slice'" length slice.p;
  let (List, s_List') = ((bv.List).t, (slice'.List).t);

  postcond {{ from_list`{b=length} s_List' == (from_list`{b=n} List)!!([start+length-1, start+length-2 .. start]:[length][32]) }};
};

bitvector_t_sliceUpdate_result <-
  bv_verify "bitvector_t_sliceUpdate" [] (bitvector_t_sliceUpdate_spec nBits slicestart slicelength);


//bitvector_t *bitvector_t_slice(bitvector_t *bv, uint32_t start, uint32_t length)
let bitvector_t_slice_spec (n : Int) (start : Int) (length : Int) = do {
  bv <- bitvector_t "bv" CONST n;
  
  execute [bv.p, from_cryptol {{ `start : [32] }}, from_cryptol {{ `length : [32] }}];

  pslice <- pointer CONST (struct_t "bitvector_t");
  slice' <- bitvector_t' "slice'" length pslice;
  let (List, s_List') = ((bv.List).t, (slice'.List).t);

  postcond {{ from_list`{b=length} s_List' == (from_list`{b=n} List)!!([start+length-1, start+length-2 .. start]:[length][32]) }};

  returns pslice;
};

bitvector_t_slice_result <-
  bv_verify "bitvector_t_slice" [] (bitvector_t_slice_spec nBits slicestart slicelength);


//sequence_t *bitvector_t_split(bitvector_t *bv, uint32_t parts)
let bitvector_t_split_spec (n : Int) (parts : Int) = do {
  bv <- bitvector_t "bv" WRITE n;

  execute [bv.p, from_cryptol {{ `parts : [32] }}];

  pseq <- pointer CONST (struct_t "sequence_t");
//  seq <- sequence_t' "sequence" parts n pseq;

//  let List_seq = (seq.List).t;
//  let List_bv = (bv.List).t;

//  postcond {{ split`{parts=parts} (from_list`{b=n} List_bv) == [ from_list`{b=n/parts} List_seqi | List_seqi <- List_seq ] }};

  returns pseq;
};

bitvector_t_split_result <-
  bv_verify "bitvector_t_split" [] (bitvector_t_split_spec 128 2);
  

//bitvector_t *sequence_t_join(sequence_t *sequence)
let sequence_t_join_spec (n : Int) (parts : Int) = do {
  seq <- sequence_t "seq" CONST parts n;

  execute [seq.p];

  pbv <- pointer CONST (struct_t "bitvector_t");
  bv <- bitvector_t' "bv" (eval_int {{ (`n : [32]) * `parts }}) pbv;
  let List_bv = (bv.List).t;
  let List_seq = (seq.List).t;
  
  postcond {{ join [ from_list`{b=n} List_seqi | List_seqi <- List_seq] == (from_list`{b=n*parts} List_bv) }};

  returns pbv;
};

sequence_t_join_result <-
  bv_verify "sequence_t_join" [] (sequence_t_join_spec 64 2);


//uint8_t bitvector_t_equal(bitvector_t *x, bitvector_t *y)
let bitvector_t_equal_spec (n : Int) = do {
  x <- bitvector_t "x" WRITE n;
  y <- bitvector_t "y" WRITE n;

  execute [x.p, y.p];

  let (x_List, y_List) = ((x.List).t, (y.List).t);

  returns (from_cryptol {{ if (from_list`{b=n} x_List) == (from_list`{b=n} y_List) then 1 else 0 : [8]}} );
};

bitvector_t_equal_result <-
  bv_verify "bitvector_t_equal" [] (bitvector_t_equal_spec nBits);


//void bitvector_t_xorUpdate(bitvector_t *x, bitvector_t *y)
let bitvector_t_xorUpdate_spec (n : Int) = do {
  x <- bitvector_t "x" WRITE n;
  y <- bitvector_t "y" CONST n;

  execute [x.p, y.p];

  x' <- bitvector_t' "bv" n x.p;
  let (x_List', x_List, y_List) = ((x'.List).t, (x.List).t, (y.List).t);

  postcond {{ (from_list`{b=n} x_List') == ((from_list`{b=n} x_List) ^ (from_list`{b=n} y_List)) }};
};

bitvector_t_xorUpdate_result <-
  bv_verify "bitvector_t_xorUpdate" [] (bitvector_t_xorUpdate_spec nBits);


//void bitvector_t_xor(bitvector_t *x, bitvector_t *y)
let bitvector_t_xor_spec (n : Int) = do {
  x <- bitvector_t "x" CONST n;
  y <- bitvector_t "y" CONST n;

  execute [x.p, y.p];

  retp <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "bv" n retp;
  let (ret_List, x_List, y_List) = ((ret.List).t, (x.List).t, (y.List).t);

  postcond {{ (from_list`{b=n} ret_List) == ((from_list`{b=n} x_List) ^ (from_list`{b=n} y_List)) }};

  returns ret.p;
};

bitvector_t_xor_result <-
  bv_verify "bitvector_t_xor" [bitvector_t_xorUpdate_result] (bitvector_t_xor_spec nBits);


//void bitvector_t_orUpdate(bitvector_t *x, bitvector_t *y)
let bitvector_t_orUpdate_spec (n : Int) = do {
  x <- bitvector_t "x" WRITE n;
  y <- bitvector_t "y" CONST n;

  execute [x.p, y.p];

  x' <- bitvector_t' "bv" n x.p;
  let (x_List', x_List, y_List) = ((x'.List).t, (x.List).t, (y.List).t);

  postcond {{ (from_list`{b=n} x_List') == ((from_list`{b=n} x_List) || (from_list`{b=n} y_List)) }};
};

bitvector_t_orUpdate_result <-
  bv_verify "bitvector_t_orUpdate" [] (bitvector_t_orUpdate_spec nBits);


//void bitvector_t_or(bitvector_t *x, bitvector_t *y)
let bitvector_t_or_spec (n : Int) = do {
  x <- bitvector_t "x" CONST n;
  y <- bitvector_t "y" CONST n;

  execute [x.p, y.p];

  retp <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "bv" n retp;
  let (ret_List, x_List, y_List) = ((ret.List).t, (x.List).t, (y.List).t);

  postcond {{ (from_list`{b=n} ret_List) == ((from_list`{b=n} x_List) || (from_list`{b=n} y_List)) }};

  returns ret.p;
};

bitvector_t_or_result <-
  bv_verify "bitvector_t_or" [bitvector_t_orUpdate_result] (bitvector_t_or_spec nBits);


//void bitvector_t_andUpdate(bitvector_t *x, bitvector_t *y)
let bitvector_t_andUpdate_spec (n : Int) = do {
  x <- bitvector_t "x" WRITE n;
  y <- bitvector_t "y" CONST n;

  execute [x.p, y.p];

  x' <- bitvector_t' "bv" n x.p;
  let (x_List', x_List, y_List) = ((x'.List).t, (x.List).t, (y.List).t);

  postcond {{ (from_list`{b=n} x_List') == ((from_list`{b=n} x_List) && (from_list`{b=n} y_List)) }};
};

bitvector_t_andUpdate_result <-
  bv_verify "bitvector_t_andUpdate" [] (bitvector_t_andUpdate_spec nBits);


//void bitvector_t_and(bitvector_t *x, bitvector_t *y)
let bitvector_t_and_spec (n : Int) = do {
  x <- bitvector_t "x" CONST n;
  y <- bitvector_t "y" CONST n;

  execute [x.p, y.p];

  retp <- pointer CONST (struct_t "bitvector_t");
  ret <- bitvector_t' "bv" n retp;
  let (ret_List, x_List, y_List) = ((ret.List).t, (x.List).t, (y.List).t);

  postcond {{ (from_list`{b=n} ret_List) == ((from_list`{b=n} x_List) && (from_list`{b=n} y_List)) }};

  returns ret.p;
};

bitvector_t_and_result <-
  bv_verify "bitvector_t_and" [bitvector_t_andUpdate_result] (bitvector_t_and_spec nBits);
